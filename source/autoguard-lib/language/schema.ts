import * as guard from "./guard";
import * as is from "../is";
import * as shared from "../shared";
import * as tokenization from "../tokenization";
import * as types from "./types";

export class Schema {
	private guards: Array<guard.Guard>;

	private getImports(): Array<shared.Import> {
		let imports = new Map<string, string[]>();
		for (let guard of this.guards) {
			let entries = guard.type.getImports();
			for (let entry of entries) {
				imports.set(entry.typename, entry.path);
			}
		}
		return Array.from(imports.entries())
			.sort((one, two) => one[0].localeCompare(two[0]))
			.map((entry) => {
				return {
					path: entry[1],
					typename: entry[0]
				};
			});
	}

	private constructor(guards: Array<guard.Guard>) {
		this.guards = guards;
	}

	generateSchema(options: shared.Options): string {
		let lines = new Array<string>();
		for (let guard of this.guards) {
			lines.push(guard.generateSchema(options));
		}
		lines.push(``);
		return lines.join(options.eol);
	}

	generateModule(options: shared.Options): string {
		let lines = new Array<string>();
		lines.push(`// This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.`);
		lines.push(``);
		let imports = this.getImports();
		for (let entry of imports) {
			lines.push(`import { ${entry.typename} } from "${entry.path.join("/")}";`);
		}
		lines.push(`import * as autoguard from "@joelek/ts-autoguard";`);
		lines.push(``);
		for (let guard of this.guards) {
			lines.push(`export type ${guard.typename} = ${guard.type.generateType(options)};`);
			lines.push(``);
			lines.push(`export const ${guard.typename} = ${guard.type.generateTypeGuard({ ...options, eol: options.eol })};`);
			lines.push(``);
		}
		let guards = new types.ObjectType();
		for (let guard of this.guards) {
			guards.add(guard.typename, {
				type: new types.ReferenceType([], guard.typename),
				optional: false
			});
		}
		lines.push(`export namespace Autoguard {`);
		lines.push(`\texport type Guards = ${guards.generateType({ ...options, eol: options.eol + "\t" })};`);
		lines.push(``);
		lines.push(`\texport const Guards = ${guards.generateType({ ...options, eol: options.eol + "\t" })};`);
		lines.push(`};`);
		lines.push(``);
		return lines.join(options.eol);
	}

	static parseOld(tokenizer: tokenization.Tokenizer): Schema {
		return tokenizer.newContext((read, peek) => {
			let guards = new Array<guard.Guard>();
			tokenization.expect(read(), "{");
			while (peek()?.value !== "}") {
				let identifier = tokenization.expect(read(), "IDENTIFIER").value;
				tokenization.expect(read(), ":");
				let type = types.Type.parse(tokenizer);
				guards.push(new guard.Guard(identifier, type));
				if (peek()?.family === ",") {
					tokenization.expect(read(), ",");
				} else {
					break;
				}
			}
			tokenization.expect(read(), "}");
			if (is.present(peek())) {
				throw `Expected end of stream!`;
			}
			return new Schema(guards);
		});
	}

	static parse(tokenizer: tokenization.Tokenizer): Schema {
		return tokenizer.newContext((read, peek) => {
			let guards = new Array<guard.Guard>();
			while (peek()) {
				try {
					guards.push(guard.Guard.parse(tokenizer));
					continue;
				} catch (error) {}
				throw `Expected code to be unreachable!`;
			}
			return new Schema(guards);
		});
	}
};

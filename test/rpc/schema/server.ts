// This file was auto-generated by @joelek/ts-autoguard. Edit at own risk.

import * as autoguard from "../../../dist/lib-server";
import * as shared from "./index";

export type Server = autoguard.api.RequestListener;

export const makeServer = (routes: autoguard.api.Server<shared.Autoguard.Requests, shared.Autoguard.Responses>, serverOptions?: autoguard.api.ServerOptions): Server => {
	let endpoints = new Array<autoguard.api.Endpoint>();
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "POST";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["POST:/"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["POST:/"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["POST:/"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("one")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/one"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/one"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/one"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("one")));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/one/"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/one/"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/one/"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("one")));
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("two")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/one/two"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/one/two"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/one/two"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["dynamic_component"] = matchers[0].getValue();
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/<dynamic_component>"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/<dynamic_component>"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/<dynamic_component>"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["dynamic_plain_component"] = matchers[0].getValue();
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/<dynamic_plain_component>"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/<dynamic_plain_component>"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/<dynamic_plain_component>"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, false, autoguard.guards.Boolean));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["dynamic_boolean_component"] = matchers[0].getValue();
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/<dynamic_boolean_component>"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/<dynamic_boolean_component>"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/<dynamic_boolean_component>"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, false, autoguard.guards.Number));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["dynamic_number_component"] = matchers[0].getValue();
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/<dynamic_number_component>"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/<dynamic_number_component>"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/<dynamic_number_component>"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["dynamic_string_component"] = matchers[0].getValue();
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/<dynamic_string_component>"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/<dynamic_string_component>"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/<dynamic_string_component>"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["dynamic_component_one"] = matchers[0].getValue();
				options["dynamic_component_two"] = matchers[1].getValue();
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/<dynamic_component_one>/<dynamic_component_two>"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/<dynamic_component_one>/<dynamic_component_two>"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/<dynamic_component_one>/<dynamic_component_two>"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, true, autoguard.guards.String));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["quoted key"] = matchers[0].getValue();
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/<quoted key>"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/<quoted key>"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/<quoted key>"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("%22r%C3%A4ksm%C3%B6rg%C3%A5s%22")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/%22r%C3%A4ksm%C3%B6rg%C3%A5s%22"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/%22r%C3%A4ksm%C3%B6rg%C3%A5s%22"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/%22r%C3%A4ksm%C3%B6rg%C3%A5s%22"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("parameters01")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/parameters01"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/parameters01"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/parameters01"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("parameters02")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["required_boolean_parameter"] = autoguard.api.decodeParameterValue(raw.parameters, "required_boolean_parameter", false);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/parameters02"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/parameters02"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/parameters02"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("parameters03")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["optional_boolean_parameter"] = autoguard.api.decodeParameterValue(raw.parameters, "optional_boolean_parameter", false);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/parameters03"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/parameters03"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/parameters03"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("parameters04")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["required_number_parameter"] = autoguard.api.decodeParameterValue(raw.parameters, "required_number_parameter", false);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/parameters04"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/parameters04"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/parameters04"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("parameters05")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["optional_number_parameter"] = autoguard.api.decodeParameterValue(raw.parameters, "optional_number_parameter", false);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/parameters05"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/parameters05"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/parameters05"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("parameters06")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["required_string_parameter"] = autoguard.api.decodeParameterValue(raw.parameters, "required_string_parameter", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/parameters06"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/parameters06"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/parameters06"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("parameters07")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["optional_string_parameter"] = autoguard.api.decodeParameterValue(raw.parameters, "optional_string_parameter", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/parameters07"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/parameters07"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/parameters07"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("parameters08")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["parameter_one"] = autoguard.api.decodeParameterValue(raw.parameters, "parameter_one", true);
				options["parameter_two"] = autoguard.api.decodeParameterValue(raw.parameters, "parameter_two", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/parameters08"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/parameters08"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/parameters08"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("parameters09")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["quoted key"] = autoguard.api.decodeParameterValue(raw.parameters, "quoted key", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/parameters09"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/parameters09"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/parameters09"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("parameters10")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["required_parameter"] = autoguard.api.decodeParameterValue(raw.parameters, "required_parameter", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/parameters10"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/parameters10"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/parameters10"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("parameters11")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["optional_parameter"] = autoguard.api.decodeParameterValue(raw.parameters, "optional_parameter", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/parameters11"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/parameters11"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/parameters11"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("parameters12")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["required_plain_parameter"] = autoguard.api.decodeParameterValue(raw.parameters, "required_plain_parameter", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/parameters12"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/parameters12"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/parameters12"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("parameters13")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["optional_plain_parameter"] = autoguard.api.decodeParameterValue(raw.parameters, "optional_plain_parameter", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/parameters13"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/parameters13"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/parameters13"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("query02")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["required_boolean_parameter"] = autoguard.api.decodeParameterValue(raw.parameters, "required_boolean_parameter", false);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/query02"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/query02"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/query02"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("query03")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["optional_boolean_parameter"] = autoguard.api.decodeParameterValue(raw.parameters, "optional_boolean_parameter", false);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/query03"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/query03"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/query03"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("query04")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["required_number_parameter"] = autoguard.api.decodeParameterValue(raw.parameters, "required_number_parameter", false);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/query04"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/query04"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/query04"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("query05")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["optional_number_parameter"] = autoguard.api.decodeParameterValue(raw.parameters, "optional_number_parameter", false);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/query05"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/query05"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/query05"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("query06")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["required_string_parameter"] = autoguard.api.decodeParameterValue(raw.parameters, "required_string_parameter", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/query06"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/query06"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/query06"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("query07")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["optional_string_parameter"] = autoguard.api.decodeParameterValue(raw.parameters, "optional_string_parameter", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/query07"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/query07"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/query07"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("query08")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["parameter_one"] = autoguard.api.decodeParameterValue(raw.parameters, "parameter_one", true);
				options["parameter_two"] = autoguard.api.decodeParameterValue(raw.parameters, "parameter_two", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/query08"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/query08"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/query08"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("query09")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["quoted key"] = autoguard.api.decodeParameterValue(raw.parameters, "quoted key", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/query09"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/query09"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/query09"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("query10")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["required_parameter"] = autoguard.api.decodeParameterValue(raw.parameters, "required_parameter", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/query10"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/query10"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/query10"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("query11")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["optional_parameter"] = autoguard.api.decodeParameterValue(raw.parameters, "optional_parameter", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/query11"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/query11"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/query11"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("query12")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["required_plain_parameter"] = autoguard.api.decodeParameterValue(raw.parameters, "required_plain_parameter", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/query12"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/query12"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/query12"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("query13")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["optional_plain_parameter"] = autoguard.api.decodeParameterValue(raw.parameters, "optional_plain_parameter", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/query13"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/query13"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/query13"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("request_headers01")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/request_headers01"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/request_headers01"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/request_headers01"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("request_headers02")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers["required_boolean_request_header"] = autoguard.api.decodeHeaderValue(raw.headers, "required_boolean_request_header", false);
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/request_headers02"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/request_headers02"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/request_headers02"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("request_headers03")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers["optional_boolean_request_header"] = autoguard.api.decodeHeaderValue(raw.headers, "optional_boolean_request_header", false);
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/request_headers03"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/request_headers03"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/request_headers03"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("request_headers04")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers["required_number_request_header"] = autoguard.api.decodeHeaderValue(raw.headers, "required_number_request_header", false);
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/request_headers04"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/request_headers04"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/request_headers04"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("request_headers05")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers["optional_number_request_header"] = autoguard.api.decodeHeaderValue(raw.headers, "optional_number_request_header", false);
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/request_headers05"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/request_headers05"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/request_headers05"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("request_headers06")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers["required_string_request_header"] = autoguard.api.decodeHeaderValue(raw.headers, "required_string_request_header", true);
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/request_headers06"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/request_headers06"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/request_headers06"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("request_headers07")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers["optional_string_request_header"] = autoguard.api.decodeHeaderValue(raw.headers, "optional_string_request_header", true);
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/request_headers07"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/request_headers07"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/request_headers07"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("request_headers08")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers["request_header_one"] = autoguard.api.decodeHeaderValue(raw.headers, "request_header_one", true);
				headers["request_header_two"] = autoguard.api.decodeHeaderValue(raw.headers, "request_header_two", true);
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/request_headers08"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/request_headers08"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/request_headers08"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("request_headers09")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers["quoted key"] = autoguard.api.decodeHeaderValue(raw.headers, "quoted key", true);
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/request_headers09"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/request_headers09"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/request_headers09"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("request_headers10")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers["required_request_header"] = autoguard.api.decodeHeaderValue(raw.headers, "required_request_header", true);
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/request_headers10"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/request_headers10"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/request_headers10"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("request_headers11")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers["optional_request_header"] = autoguard.api.decodeHeaderValue(raw.headers, "optional_request_header", true);
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/request_headers11"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/request_headers11"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/request_headers11"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("request_headers12")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers["required_plain_request_header"] = autoguard.api.decodeHeaderValue(raw.headers, "required_plain_request_header", true);
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/request_headers12"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/request_headers12"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/request_headers12"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("request_headers13")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers["optional_plain_request_header"] = autoguard.api.decodeHeaderValue(raw.headers, "optional_plain_request_header", true);
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/request_headers13"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/request_headers13"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/request_headers13"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("response_headers01")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/response_headers01"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/response_headers01"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/response_headers01"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("response_headers02")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/response_headers02"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/response_headers02"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/response_headers02"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeHeaderPairs("required_boolean_response_header", [response.headers?.["required_boolean_response_header"]], false));
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("response_headers03")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/response_headers03"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/response_headers03"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/response_headers03"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeHeaderPairs("optional_boolean_response_header", [response.headers?.["optional_boolean_response_header"]], false));
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("response_headers04")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/response_headers04"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/response_headers04"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/response_headers04"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeHeaderPairs("required_number_response_header", [response.headers?.["required_number_response_header"]], false));
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("response_headers05")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/response_headers05"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/response_headers05"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/response_headers05"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeHeaderPairs("optional_number_response_header", [response.headers?.["optional_number_response_header"]], false));
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("response_headers06")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/response_headers06"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/response_headers06"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/response_headers06"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeHeaderPairs("required_string_response_header", [response.headers?.["required_string_response_header"]], true));
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("response_headers07")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/response_headers07"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/response_headers07"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/response_headers07"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeHeaderPairs("optional_string_response_header", [response.headers?.["optional_string_response_header"]], true));
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("response_headers08")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/response_headers08"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/response_headers08"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/response_headers08"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeHeaderPairs("response_header_one", [response.headers?.["response_header_one"]], true));
								headers.push(...autoguard.api.encodeHeaderPairs("response_header_two", [response.headers?.["response_header_two"]], true));
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("response_headers09")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/response_headers09"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/response_headers09"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/response_headers09"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeHeaderPairs("quoted key", [response.headers?.["quoted key"]], true));
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("response_headers10")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/response_headers10"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/response_headers10"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/response_headers10"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeHeaderPairs("required_response_header", [response.headers?.["required_response_header"]], true));
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("response_headers11")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/response_headers11"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/response_headers11"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/response_headers11"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeHeaderPairs("optional_response_header", [response.headers?.["optional_response_header"]], true));
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("response_headers12")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/response_headers12"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/response_headers12"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/response_headers12"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeHeaderPairs("required_plain_response_header", [response.headers?.["required_plain_response_header"]], true));
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("response_headers13")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/response_headers13"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/response_headers13"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/response_headers13"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeHeaderPairs("optional_plain_response_header", [response.headers?.["optional_plain_response_header"]], true));
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("request_payload01")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/request_payload01"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/request_payload01"](new autoguard.api.ClientRequest(request, false, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/request_payload01"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("request_payload02")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/request_payload02"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/request_payload02"](new autoguard.api.ClientRequest(request, false, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/request_payload02"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("response_payload01")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/response_payload01"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/response_payload01"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/response_payload01"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("response_payload02")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/response_payload02"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/response_payload02"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/response_payload02"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("full_example")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["parameter"] = autoguard.api.decodeParameterValue(raw.parameters, "parameter", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers["request_header"] = autoguard.api.decodeHeaderValue(raw.headers, "request_header", true);
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = await autoguard.api.deserializePayload(raw.payload);
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/full_example"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/full_example"](new autoguard.api.ClientRequest(request, false, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/full_example"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeHeaderPairs("response_header", [response.headers?.["response_header"]], true));
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("reference")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/reference"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/reference"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/reference"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = autoguard.api.serializePayload(response.payload);
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/json; charset=utf-8"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("binary_request")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/binary_request"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/binary_request"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/binary_request"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("binary_response")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/binary_response"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/binary_response"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/binary_response"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("number")));
		matchers.push(new autoguard.api.DynamicRouteMatcher(1, 1, false, autoguard.guards.Number));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["number"] = matchers[1].getValue();
				options["number"] = autoguard.api.decodeParameterValue(raw.parameters, "number", false);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["GET:/number/<number>"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["GET:/number/<number>"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["GET:/number/<number>"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	endpoints.push((raw, auxillary) => {
		let method = "GET";
		let matchers = new Array<autoguard.api.RouteMatcher>();
		matchers.push(new autoguard.api.StaticRouteMatcher(decodeURIComponent("")));
		return {
			acceptsComponents: () => autoguard.api.acceptsComponents(raw.components, matchers),
			acceptsMethod: () => autoguard.api.acceptsMethod(raw.method, method),
			validateRequest: async () => {
				let options: Record<string, autoguard.api.JSON> = {};
				options["required"] = autoguard.api.decodeParameterValue(raw.parameters, "required", true);
				options["optional"] = autoguard.api.decodeParameterValue(raw.parameters, "optional", true);
				options["repeated"] = autoguard.api.decodeParameterValues(raw.parameters, "repeated", true);
				options = { ...options, ...autoguard.api.decodeUndeclaredParameters(raw.parameters, Object.keys(options)) };
				let headers: Record<string, autoguard.api.JSON> = {};
				headers = { ...headers, ...autoguard.api.decodeUndeclaredHeaders(raw.headers, Object.keys(headers)) };
				let payload = raw.payload;
				let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Requests["queryParameters"], serverOptions?.debugMode);
				let request = guard.as({ options, headers, payload }, "request");
				return {
					handleRequest: async () => {
						let response = await routes["queryParameters"](new autoguard.api.ClientRequest(request, true, auxillary));
						return {
							validateResponse: async () => {
								let guard = autoguard.api.wrapMessageGuard(shared.Autoguard.Responses["queryParameters"], serverOptions?.debugMode);
								guard.as(response, "response");
								let status = response.status ?? 200;
								let headers = new Array<[string, string]>();
								headers.push(...autoguard.api.encodeUndeclaredHeaderPairs(response.headers ?? {}, headers.map((header) => header[0])));
								let payload = response.payload ?? [];
								let defaultHeaders = serverOptions?.defaultHeaders?.slice() ?? [];
								defaultHeaders.push(["Content-Type", "application/octet-stream"]);
								return autoguard.api.finalizeResponse({ status, headers, payload }, defaultHeaders);
							}
						};
					}
				};
			}
		};
	});
	return (request, response) => autoguard.api.route(endpoints, request, response, serverOptions);
};
